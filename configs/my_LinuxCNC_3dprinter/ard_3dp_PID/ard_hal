#!/usr/bin/python3
#    HAL userspace component to interface with Arduino board
#    Copyright (C) 2007 Jeff Epler <jepler@unpythonic.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
import serial
import hal
import sys
import time
import math

def encode(addr, data):
    if data < 0 or data > 2048: raise ValueError("data %02d out of range" % data)
    if addr < 0 or addr > 8: raise ValueError("address %02d out of range" % addr)
    b1 = 0x80 | (addr << 4) | (data >> 7)
    b2 = data & 0x7f
    return chr(b1) + chr(b2)

PORT = "/dev/ttyUSB0"

if len(sys.argv) > 1:
    PORT = sys.argv[1]

if len(sys.argv) > 2:
    nout = int(sys.argv[2])
else:
    nout = 6

if nout > 6 or nout < 0:
    raise SystemExit("Number of digital outputs must be from 0 to 6")

pinmap = [2,4,8,9,12,13]
dacpinmap = [3,5,6,7,10,11]

ser = serial.Serial(PORT, 9600, timeout=15)

c = hal.component("arduino");
c.newpin("analog-in-00", hal.HAL_FLOAT, hal.HAL_OUT);
c.newpin("analog-in-01", hal.HAL_FLOAT, hal.HAL_OUT);
c.newpin("analog-in-02", hal.HAL_FLOAT, hal.HAL_OUT);
c.newpin("analog-in-03", hal.HAL_FLOAT, hal.HAL_OUT);
c.newpin("analog-in-04", hal.HAL_FLOAT, hal.HAL_OUT);
c.newpin("analog-in-05", hal.HAL_FLOAT, hal.HAL_OUT);
c.newparam("analog-in-00-temp", hal.HAL_BIT, hal.HAL_RW);
c.newparam("analog-in-01-temp", hal.HAL_BIT, hal.HAL_RW);
c.newparam("analog-in-02-temp", hal.HAL_BIT, hal.HAL_RW);
c.newparam("analog-in-03-temp", hal.HAL_BIT, hal.HAL_RW);
c.newparam("analog-in-04-temp", hal.HAL_BIT, hal.HAL_RW);
c.newparam("analog-in-05-temp", hal.HAL_BIT, hal.HAL_RW);


c.newpin("analog-out-03", hal.HAL_FLOAT, hal.HAL_IN);
c.newparam("analog-out-03-offset", hal.HAL_FLOAT, hal.HAL_RW);
c.newparam("analog-out-03-scale", hal.HAL_FLOAT, hal.HAL_RW);
c.newpin("analog-out-05", hal.HAL_FLOAT, hal.HAL_IN);
c.newparam("analog-out-05-offset", hal.HAL_FLOAT, hal.HAL_RW);
c.newparam("analog-out-05-scale", hal.HAL_FLOAT, hal.HAL_RW);
c.newpin("analog-out-06", hal.HAL_FLOAT, hal.HAL_IN);
c.newparam("analog-out-06-offset", hal.HAL_FLOAT, hal.HAL_RW);
c.newparam("analog-out-06-scale", hal.HAL_FLOAT, hal.HAL_RW);
c.newpin("analog-out-07", hal.HAL_FLOAT, hal.HAL_IN);
c.newparam("analog-out-07-offset", hal.HAL_FLOAT, hal.HAL_RW);
c.newparam("analog-out-07-scale", hal.HAL_FLOAT, hal.HAL_RW);
c.newpin("analog-out-10", hal.HAL_FLOAT, hal.HAL_IN);
c.newparam("analog-out-10-offset", hal.HAL_FLOAT, hal.HAL_RW);
c.newparam("analog-out-10-scale", hal.HAL_FLOAT, hal.HAL_RW);
c.newpin("analog-out-11", hal.HAL_FLOAT, hal.HAL_IN);
c.newparam("analog-out-11-offset", hal.HAL_FLOAT, hal.HAL_RW);
c.newparam("analog-out-11-scale", hal.HAL_FLOAT, hal.HAL_RW);

c['analog-in-00-temp'] = 0;
c['analog-in-01-temp'] = 0;
c['analog-in-02-temp'] = 0;
c['analog-in-03-temp'] = 0;
c['analog-in-04-temp'] = 0;
c['analog-in-05-temp'] = 0;

c['analog-out-03-scale'] = 1.0;
c['analog-out-05-scale'] = 1.0;
c['analog-out-06-scale'] = 1.0;
c['analog-out-07-scale'] = 1.0;
c['analog-out-10-scale'] = 1.0;
c['analog-out-11-scale'] = 1.0;
c['analog-out-03-offset'] = 0;
c['analog-out-05-offset'] = 0;
c['analog-out-06-offset'] = 0;
c['analog-out-07-offset'] = 0;
c['analog-out-10-offset'] = 0;
c['analog-out-11-offset'] = 0;
c.newpin("digital-out-02", hal.HAL_BIT, hal.HAL_IN);
c.newparam("digital-out-02-invert", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-out-04", hal.HAL_BIT, hal.HAL_IN);
c.newparam("digital-out-04-invert", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-out-08", hal.HAL_BIT, hal.HAL_IN);
c.newparam("digital-out-08-invert", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-out-09", hal.HAL_BIT, hal.HAL_IN);
c.newparam("digital-out-09-invert", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-out-12", hal.HAL_BIT, hal.HAL_IN);
c.newparam("digital-out-12-invert", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-out-13", hal.HAL_BIT, hal.HAL_IN);
c.newparam("digital-out-13-invert", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-in-02", hal.HAL_BIT, hal.HAL_OUT);
c.newpin("digital-in-02-not", hal.HAL_BIT, hal.HAL_OUT);
c.newparam("digital-in-02-pullup", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-in-04", hal.HAL_BIT, hal.HAL_OUT);
c.newpin("digital-in-04-not", hal.HAL_BIT, hal.HAL_OUT);
c.newparam("digital-in-04-pullup", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-in-08", hal.HAL_BIT, hal.HAL_OUT);
c.newpin("digital-in-08-not", hal.HAL_BIT, hal.HAL_OUT);
c.newparam("digital-in-08-pullup", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-in-09", hal.HAL_BIT, hal.HAL_OUT);
c.newpin("digital-in-09-not", hal.HAL_BIT, hal.HAL_OUT);
c.newparam("digital-in-09-pullup", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-in-12", hal.HAL_BIT, hal.HAL_OUT);
c.newpin("digital-in-12-not", hal.HAL_BIT, hal.HAL_OUT);
c.newparam("digital-in-12-pullup", hal.HAL_BIT, hal.HAL_RW);
c.newpin("digital-in-13", hal.HAL_BIT, hal.HAL_OUT);
c.newpin("digital-in-13-not", hal.HAL_BIT, hal.HAL_OUT);
c.newparam("digital-in-13-pullup", hal.HAL_BIT, hal.HAL_RW);
time.sleep(2)
c.ready()

firstbyte = 0
state = 0
try:
    while 1:
        while ser.inWaiting():
            byte = ord(ser.read())
            if firstbyte & 0x80 == 0x80 and byte & 0x80 == 0:
                v = (firstbyte << 7) | byte
                port = (v >> 11) & 7

                if port < 6:
                    if port >= nout:
                        b = v & 1024
                        c['digital-in-%02d' % pinmap[port]] = b != 0
                        c['digital-in-%02d-not' % pinmap[port]] = b == 0

                    temp = c['analog-in-%02d-temp' % port]
                    if (temp == 1):
                        seriesresistor = 10000;
                        resistance = (seriesresistor / (1024 / (v & 1023)))
                        thermistornominal = 118000;
                        tempnominal = 25;
                        bcoeff = 3950;
                        steinhart = (resistance / thermistornominal);
                        steinhart = math.log(steinhart);
                        steinhart = (steinhart / bcoeff);
                        steinhart = (steinhart + (tempnominal + 273.15));
                        steinhart = (1 / steinhart);
                        steinhart = (steinhart - 273.15);
                        value = math.floor(steinhart);
                    else:
                        value = (v & 1023);
                    c['analog-in-%02d' % port] = value

            firstbyte = byte
        
        scale = c['analog-out-%02d-scale' % dacpinmap[state]] or 1.
        offset = c['analog-out-%02d-offset' % dacpinmap[state]]
        data = (c['analog-out-%02d' % dacpinmap[state]] - offset) / scale / 255
        data = int(data * 255 + 0.5)
        if data < 0: data = 0
        if data > 255: data = 255
        if state < nout:
            out = not c['digital-out-%02d' % pinmap[state]]
            invert = not c['digital-out-%02d-invert' % pinmap[state]]
            if out != invert:
                data |= 0x200
            data = data | 0x100
        else:
            pullup = c['digital-in-%02d-pullup' % pinmap[state]]
            if pullup:
                data |= 0x200
        data = data | (state << 11)
        outa = (0x80 | (data >> 7))
        outb = (data & 0x7f)
        ser.write(outa.to_bytes(1,byteorder='big'))
        ser.write(outb.to_bytes(1,byteorder='big'))
        state = (state+1) % 6
        time.sleep(.001)
except KeyboardInterrupt:
	raise SystemExit

