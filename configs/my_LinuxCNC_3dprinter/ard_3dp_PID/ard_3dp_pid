#!/usr/bin/python
#    HAL userspace component to interface with Arduino board
#    by Colin Kingsbury (http://ckcnc.wordpress.com_)
#    Inspired by the earlier example from Jeff Epler
#
#    Modified by Duane Bishop for use with EMC-2-Arduino
#	(https://github.com/dewy721/EMC-2-Arduino)
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
import serial
import hal
import sys
import time

#First we open the serial port. This should correspond to the port the Arduino
#is connected to. This can be found in the Arduino IDE in Tools->Serial Port
PORT = "/dev/ttyACM0"
ser = serial.Serial(PORT, 115200, timeout=15)

#Now we create the HAL component and its pins
c = hal.component("arduino")
c.newpin("set-a",hal.HAL_FLOAT,hal.HAL_IN)
c.newpin("set-b",hal.HAL_FLOAT,hal.HAL_IN)
c.newpin("tempa",hal.HAL_FLOAT,hal.HAL_IN)
c.newpin("tempb",hal.HAL_FLOAT,hal.HAL_IN)
c.newpin("attempa",hal.HAL_BIT,hal.HAL_IN)
c.newpin("attempb",hal.HAL_BIT,hal.HAL_IN)
c.newpin("pwm-a",hal.HAL_FLOAT,hal.HAL_IN)
c.newpin("pwm-b",hal.HAL_FLOAT,hal.HAL_IN)
time.sleep(2)
c.ready()

#We save the machine state (i.e. whether it's off or on) so that we only
#send a message to the Arduino when it changes
machineState = c['machine-state']
eStopState = c['eStop']
set_a = c['set-a']
set_b = c['set-b']
pwm_a = c['pwm-a']
pwm_b = c['pwm-b']
#Check if the machine is on and set the LED accordingly
if(machineState != 1):
  ser.write("+P")

set_aOld = 0;
set_bOld = 0;

try:
  while 1:
    time.sleep(.01)

    set_a = c['set-a'];
    if set_a != set_aOld:
      set_aOld = set_a;
      set_a = c['set-a'] * 1000000
      ser.write("set A");
      ser.write(repr(set_a))
      ser.write(";");
      ser.write("\n");

    set_b = c['set-b'];
    if set_b != set_bOld:
      set_bOld = set_b;
      set_b = c['set-b'] * 1000000
      ser.write("set B");
      ser.write(repr(set_b))
      ser.write(";");
      ser.write("\n");

    pwm_a = c['pwm-a'];
    if pwm_a != set_bOld:
      set_bOld = pwm_a;
      set_a = c['set-a'] * 1000000
      ser.write("set C");
      ser.write(repr(pwm_a))
      ser.write(";");
      ser.write("\n");

    pwm_b = c['pwm-b'];
    if pwm_b != set_bOld:
      set_bOld = pwm_b;
      pwm_b = c['pwm-b'] * 1000000
      ser.write("set D");
      ser.write(repr(pwm_b))
      ser.write(";");
      ser.write("\n");

    #Check to see if we have a message waiting from the Arduino
    while ser.inWaiting():
      #This should be set to the length of whatever fixed-length message
      #you're sending from the arduino. It does not have to be the same length
      #as the outbound messages.
      key = ser.read(2)
      #The Arduino generates two different key events
      #One when the key is pressed down (+S) and another when it is released (-S)
      #In this case we are going to ignore the release

# Set min limit triggers
      if(key == "a0"):
        c['attempa'] = 0
      if(key == "b0"):
        c['attempb'] = 0

# Clear limit triggers
      if(key == "a1"):
        c['attempa'] = 1
      if(key == "b1"):
        c['attempb'] = 1

      tmp_a = 0;
      tmp_b = 0;
      if(key == "aa"):
        c['tempa'] = ser.read(3);
      if(key == "bb"):
        c['tempb'] = ser.read(3);
except KeyboardInterrupt:
    raise SystemExit

